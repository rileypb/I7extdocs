<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Extension</title><script type="text/javascript">	function showExtra(id, imid) {		if (document.getElementById(id).style.display == 'block') {			document.getElementById(id).style.display = 'none';			document.getElementById(imid).src = 'inform:/extra.png';		} else {			document.getElementById(id).style.display = 'block';			document.getElementById(imid).src = 'inform:/extraclose.png';		}	}    function openExtra(id, imid) {    	document.getElementById(id).style.display = 'block';    	document.getElementById(imid).src = 'inform:/extraclose.png';    }    function closeExtra(id, imid) {    	document.getElementById(id).style.display = 'none';    	document.getElementById(imid).src = 'inform:/extra.png';    }</script></head><STYLE TYPE="text/css"><!--*, *:before, *:after {-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;}.oval, .oval TD{background-image:url('../../../doc_images/ovoid.png');color:white;}--></STYLE><body><script language="JavaScript">function pasteCode(code) {    var myProject = window.Project;    myProject.selectView('source');    myProject.pasteCode(code);}</script><font face="lucida grande,geneva,arial,tahoma,verdana,helvetica,helv" size=2><table CELLPADDING=0 CELLSPACING=0 width="100%" bgcolor="#000000"><tr><TD width=38px height=26px align="center" valign="center"><img border=0 src="../../../doc_images/Hookindex.png" border=0></td><TD width=38px height=26px align="center" valign="center"></td><td halign="left" valign="center" CELLPADDING=0 CELLSPACING=0></td><TD width=56px height=26px align="right" valign="center"><img border=0 src="../../../doc_images/Hookup.png" border=0></td></tr></table><p><img border=0 src=../../../doc_images/paste.png>&nbsp;<b>Unified Glulx Input<font color="#404040"> by </font>Andrew Plotkin</b><p><small></small><p><p><hr><p>
<p>
 Unified Glulx Input is an attempt to tidy up all the messy I6 APIs that you need to customize your game's input system.
<p>
 The Glulx Entry Points extension does this already, but that exposes all the mess -- you have to understand how Glk works to use to correctly. Unified Glulx Input tries to offer you a simple model which handles common cases easily.
<p>
 (This extension was written and tested with Inform 7 releases 6L38 and 6M62.)
<p>
 Chapter: Basic concepts
<p>
 Section: Input-contexts: why are we awaiting input?
<p>
 A game can stop and await input for many reasons. It can be waiting for a command, or for a yes-or-no answer (an &quot;if the player consents...&quot; test). It can be waiting for the player to hit any key to continue.
<p>
 In Unified Glulx Input, all of these inputs invoke the same mechanism. The mechanism can be customized to behave in different ways -- printing different prompts, waiting for different sorts of input. But it's always the same mechanism underneath.
<p>
 You customize it by writing rules. The extension has five rulebooks which cover various aspects of the problem. The default rules cover the normal input situations of an IF game -- the ones mentioned above. Of course, you can modify these or add more.
<p>
 We distinguish these situations with a value called an &quot;input-context&quot;. The rulebooks we mentioned are input-context based rulebooks. The UGI extension comes with seven:
<p>
<blockquote><font color="#000080"> primary context, disambiguation context (the command input-contexts)<br> yes-no question context, extended yes-no question context, repeat yes-no question context (the yes-no input-contexts)<br> final question context<br> keystroke-wait context</font></blockquote>
<p>
 The first two (primary and disambiguation) are used by the main game loop -- the core cycle of fetching and performing commands. The others are special-purpose, ad-hoc inputs.
<p>
 These are more finely divided than you usually need to bother with. For example, the game might be waiting for a normal command (primary context) or for a disambiguation reply (disambiguation context). In most games these will appear the same. So you can handle them together. For example:
<p>
<blockquote><font color="#000080"> Prompt displaying rule for a command input-context:<br>&nbsp;&nbsp;&nbsp;&nbsp; instead say &quot;&gt;&gt;&gt;&quot;;</font></blockquote>
<p>
 This rule changes the command prompt for all main-game-loop inputs (both primary and disambiguation).
<p>
 Section: G-events: what kind of input are we awaiting?
<p>
 Most IF input comes as lines of text. But a game can also accept keystroke input, as in a &quot;hit any key&quot; prompt or a menu controlled with arrow keys.
<p>
 Glulx currently supports eight types of input, described as &quot;g-event&quot; values:
<p>
<blockquote><font color="#000080"> char-event - a keystroke<br> line-event - a line of text<br> hyperlink-event - selection of a hyperlink<br> timer-event - event repeated at fixed intervals<br> mouse-event - a mouse click<br> arrange-event - window sizes have changed<br> redraw-event - graphics windows need redrawing<br> sound-notify-event - sound finished playing</font></blockquote>
<p>
 Section: Glk-windows: what window is awaiting input?
<p>
 This version of UGI is only concerned with one window, the &quot;story-window&quot;. You can set various properties of the story-window object to customize its behavior.
<p>
 There is also a &quot;status-window&quot; object, but it is not yet functional. Future versions of UGI will support this. Future versions will also integrate with the Multiple Windows extension to support multi-window games.
<p>
 Chapter: High-level tasks
<p>
 These phrases can be used with no deeper knowledge of UGI.
<p>
 Section: Yes-no questions
<p>
<blockquote><font color="#000080"> if the player consents:...</font></blockquote>
<p>
 This works just as it always has (WWI 11.5); it waits for the player to type &quot;yes&quot; or &quot;no&quot;. You are expected to print the question first.
<p>
<blockquote><font color="#000080"> if the player consents asking (T1 - text):...<br> if the player consents asking (T1 - text) and (T2 - text):...</font></blockquote>
<p>
 Similar, except UGI uses your text as the prompt (through the magic of the prompt displaying rulebook). T1 should be the initial question; T2 is a followup if the player fails to answer. If you don't supply T2, it defaults to &quot;Please answer yes or no.&quot;
<p>
 Section: Waiting for a key
<p>
 These phrases are copied from the Basic Screen Effects extension; they have been updated here to work with UGI.
<p>
<blockquote><font color="#000080"> wait for any key<br> wait for the SPACE key</font></blockquote>
<p>
 By default no prompt is printed. You can print your own beforehand, or write a prompt displaying rule:
<p>
<blockquote><font color="#000080"> Prompt displaying rule for keystroke-wait context:<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;&gt;&gt;&gt;&quot;;</font></blockquote>
<p>
 If you want to cause a wait and then get the key that was hit:
<p>
<blockquote><font color="#000080"> the key waited for -- Unicode character</font></blockquote>
<p>
 Include the Unicode Character Names extension for a complete list of characters, or my ASCII Character Names extension for the basic ones. The result may also be a special value representing a control key:
<p>
<blockquote><font color="#000080"> special keycode left, special keycode right, special keycode up, special keycode down, special keycode return, special keycode delete, special keycode escape, special keycode tab, special keycode pageup, special keycode pagedown, special keycode home, special keycode end, special keycode func1,... special keycode func12</font></blockquote>
<p>
 These are not part of the Unicode spec, but I7 represents them as Unicode character values. (They are outside the official Unicode range of $0 to $10FFFF.) Don't try to print them or insert them into normal texts -- they have no normal printed representation. If you need to print a special character, use this phrase:
<p>
<blockquote><font color="#000080"> say extended (C - Unicode character)</font></blockquote>
<p>
 This will print special characters as &quot;left&quot;, &quot;right&quot;, and so on. Normal Unicode characters will be printed directly.
<p>
 Chapter: The five rulebooks
<p>
 We've talked about the five rulebooks, and now it's time to introduce them:
<p>
<blockquote><font color="#000080"> setting up input rules - decide what kinds of input are desired<br> prompt displaying rules - display a prompt, traditionally &quot;&gt;&quot;<br> accepting input rules - accept, reject, or alter individual input events<br> checking undo input rules - check whether an input event is an UNDO command<br> handling input rules - convert an input event into an action</font></blockquote>
<p>
 These rulebooks are based on an input-context value. So you might write
<p>
<blockquote><font color="#000080"> Prompt displaying rule for yes-or-no context:...<br> Accepting input rule for a command input-context:...</font></blockquote>
<p>
 Section: Setting up input rules
<p>
 This rulebook decides what sort of input the game desires for player commands. It also decides whether the command will be an undo step. By default it requests only line input, and says that all line inputs are undo steps.
<p>
 This rulebook applies only to the command contexts (primary and disambiguation). Other questions (yes-or-no, keystroke-wait, etc) do their own setup (and are not undo steps).
<p>
 To customize this, set the input-request, hyperlink-input-request, and mouse-input-request properties of the story-window object. For example:
<p>
<blockquote><font color="#000080"> Setting up input rule:<br>&nbsp;&nbsp;&nbsp;&nbsp; now the input-request of the story-window is char-input;<br>&nbsp;&nbsp;&nbsp;&nbsp; now the story-window is hyperlink-input-request;</font></blockquote>
<p>
 The input-request property can be char-input, line-input, or no-input. (These are mutually exclusive.) You can set hyperlink-input-request and mouse-input-request independently.
<p>
 (Note that mouse-input-request does not apply to the story-window -- buffer windows have no fixed coordinates -- so it cannot currently be used. There is a status-window object, but UGI does not yet support input requests for it.)
<p>
 To indicate whether this command is an undo step, use one of these phrases:
<p>
<blockquote><font color="#000080"> set input undoable<br> set input non-undoable</font></blockquote>
<p>
 When you set input undoable, you're telling the parser that the player *can* perform an UNDO command (whether by typing &quot;UNDO&quot; or some other way) and therefore this is a turn that should be added to the undo chain. If you set input non-undoable, you're telling the parser that UNDO is not supported for this command, and future UNDO commands should skip back over it.
<p>
 To make this more clear: when the player does an UNDO, they don't want to jump back to the previous *input*; they want to jump back to the previous *turn*. Yes-or-no commands are inputs but never turns. When the setting-up-input rulebook is called, it's *usually* a turn, but you might want to decide otherwise.
<p>
 (Note: you can suppress UNDO for your game this way, but it's better to use the &quot;undo prevention&quot; option. That way, UNDO commands will say &quot;The use of 'undo' is forbidden&quot;, rather than just throwing a &quot;not a verb I recognize&quot; error.)
<p>
 We'd better mention how to display hyperlinks in your game text. A hyperlink can contain a number or an object reference. (Or, really, any value that can be cast to an I6 integer, which is any value at all. But stick with the easy cases.) (It's best not to mix numbers and objects in the same game. Pick one.)
<p>
<blockquote><font color="#000080"> say hyperlink (O - object)<br> say hyperlink (N - number)<br> say /hyperlink</font></blockquote>
<p>
 Use these phrases in text as markup:
<p>
<blockquote><font color="#000080"> say &quot;You see a [hyperlink sword]ancient elvish sword[/hyperlink].&quot;</font></blockquote>
<p>
 Section: Prompt displaying rules
<p>
 This rulebook displays a prompt before input. It applies to all input contexts.
<p>
 The default for keystroke input is no prompt. For yes-no input it is &quot;&gt;&quot;, unless you've specified prompts by invoking the &quot;player consents asking...&quot; phrase. For the final question, the prompt is &quot;&gt; [run paragraph on]&quot; (as defined by the old print the final prompt rule).
<p>
 For other cases, including all command contexts, the prompt is &quot;&gt;&quot;. You can customize this by changing the old command prompt global variable, or by writing a rule:
<p>
<blockquote><font color="#000080"> Prompt displaying rule for a command input-context:...</font></blockquote>
<p>
 (See example: &quot;Changing the Prompt&quot;.)
<p>
 Section: Accepting input rules
<p>
 This rulebook decides whether to accept or reject an incoming event, or convert the event to a different event. It applies to all input contexts.
<p>
 This is the fussiest rulebook in UGI. It's also the one you will use least often! For many games, the default rules are all you need. So don't be overwhelmed by the description here.
<p>
 Every time an event arrives, this rulebook is invoked. You can get the event type with this phrase:
<p>
<blockquote><font color="#000080"> the current input event type -- g-event</font></blockquote>
<p>
 So you can write a rule like:
<p>
<blockquote><font color="#000080"> Handling input rule when the current input event type is hyperlink-event:</font></blockquote>
<p>
 Or, as a handy shortcut:
<p>
<blockquote><font color="#000080"> Handling input rule when handling hyperlink-event:</font></blockquote>
<p>
 Depending on the current event type, you can check its contents with one of these phrases:
<p>
<blockquote><font color="#000080"> the current input event character -- Unicode character<br> the current input event hyperlink number -- number<br> the current input event hyperlink object -- object<br> the current input event line text -- text<br> the current input event line word count -- number</font></blockquote>
<p>
 An important note: in the accepting input rulebook, the &quot;player's command&quot; snippet has not yet been set up. You cannot refer to this or any other snippet variable; you will get errors. Use the &quot;current input event line text&quot; phrase.
<p>
 The job of the accepting input rulebook is to reject the event (keep waiting) or accept it (stop waiting and allow event to be processed). These are available as phrases (really just aliases for &quot;rule succeeds&quot; and &quot;rule fails&quot;):
<p>
<blockquote><font color="#000080"> accept the input event<br> reject the input event</font></blockquote>
<p>
 The default rules accept character, line, and hyperlink events (assuming they were requested by the setting up input rules). Other event types are rejected by default, although a rearrange event will trigger a status-line refresh first.
<p>
 You can also convert the event to a different one:
<p>
<blockquote><font color="#000080"> replace the current input event with the line (T - text)<br> replace the current input event with the character (C - Unicode character)<br> replace the current input event with the hyperlink object (O - object)<br> replace the current input event with the hyperlink number (N - number)</font></blockquote>
<p>
 This is handy for simple cases -- perhaps you want to convert hyperlink clicks into a line of text and run that through the parser in the usual way. (See example: &quot;Maze of Keys&quot;.) However, it's cleaner to handle hyperlinks in the handling input rulebook. See next section.
<p>
 Here's the messy part. If you've requested character or line input, and a *different* input event arrives, the character or line input is still in progress. *You may not print text as long as character or line input is in progress. *
<p>
 To be clear, this is not a problem when you *receive* a character or line event. That signals that the input is complete and printing is safe. But if you get another event type (say a timer or hyperlink event) while char/line input is in progress, you must either
<p>
 (a) take background action that does not print to the story window, or
<p>
 (b) accept the event, printing nothing, or
<p>
 (c) interrupt text input before printing.
<p>
 The standard redraw status line on arrange rule is an example of policy (a). It redraws the status line (and then rejects the event to continue waiting). See example: &quot;Tick Tick Tick Button&quot;.
<p>
 Policy (b) is fine if you plan to handle the event in the handling input rulebook. See next section.
<p>
 For policy (c), you'll have to call this phrase:
<p>
<blockquote><font color="#000080"> interrupt text input for (W - glk-window)</font></blockquote>
<p>
 This stops line or character input. If you then reject the event, input will be re-requested automatically.
<p>
<blockquote><font color="#000080"> interrupt text input for (W - glk-window), preserving input</font></blockquote>
<p>
 This variation stores the player's in-progress input as the preload-input-text property of the story-window. The next time line input starts, the string will be pre-loaded into the input buffer. (See example: &quot;Master Blaster&quot;.)
<p>
 The interrupt text input phrase has an additional use: it tells UGI that you're about to print text, so the prompt might have to be redisplayed. This is sometimes helpful if you're rejecting an input event with an error message (rather than silently).
<p>
 Finally, I'll say again: this is the least commonly used of the five rulebooks! Forget the mess above and read on.
<p>
 Section: Checking undo input rules
<p>
 At this point an input event has been accepted. This rulebook decides whether it's an UNDO command.
<p>
 (UNDO commands are special; they never reach the handling-input stage, and they never become an &quot;undoing&quot; action. There is no such action, in fact. This is awkward but it's just the way the parser is. So we need this special rulebook to detect them.)
<p>
 The default rule in this rulebook checks for line input containing just the word &quot;UNDO&quot;. That's the expected behavior for games that accept line input.
<p>
 If your game works by keystroke or hyperlink input, you might still want to support UNDO. You could write an accepting input rule that replaces the current input event with the line &quot;undo&quot;. (See example: &quot;Maze of Keys&quot;.) However, it's cleaner to write a checking undo rule which checks for whatever UNDO input your game wants. (See example: &quot;Maze of Keys 2&quot;.)
<p>
 This is important: if you set input undoable at setting-up-input time, you *must* accept at least one input as UNDO at checking-undo-input time! If you don't, you'll break multiple undo for the player. (They won't be able to UNDO back through this command.)
<p>
 Contrariwise, if you forget to set input undoable at setting-up-input time, then UNDO will not work for this command. The checking-undo-input rulebook will be skipped.
<p>
 Section: Handling input rules
<p>
 At this point an input event has been accepted (and it wasn't UNDO). This rulebook decides how to convert it into an action.
<p>
 This rulebook applies only to the command contexts (primary and disambiguation). Other questions (yes-or-no, keystroke-wait, etc) do their own setup.
<p>
 The phrases mentioned above, for examining the input event, still apply:
<p>
<blockquote><font color="#000080"> the current input event type -- g-event<br> if handling (G - g-event):...<br> the current input event character -- Unicode character<br> the current input event hyperlink number -- number<br> the current input event hyperlink object -- object<br> the current input event line text -- text<br> the current input event line word count -- number<br> accept the input event<br> reject the input event</font></blockquote>
<p>
 If your rule rejects the event, the command does nothing. The game prompts for another command.
<p>
 If your rule accepts the event, it is processed. Line input is parsed in the classic way. Any other input type causes an &quot;I beg your pardon?&quot; error.
<p>
 So what do we do with other input types? Usually you'll invoke this phrase:
<p>
<blockquote><font color="#000080"> handle the current input event as (act - stored action)</font></blockquote>
<p>
 This bypasses the parser entirely. The game will proceed as if the given action had been parsed; the player will carry it out (or try to). For example, if you had a hyperlink labelled &quot;INVENTORY&quot;, you might write:
<p>
<blockquote><font color="#000080"> Handling input rule when handling hyperlink-event:<br>&nbsp;&nbsp;&nbsp;&nbsp; handle the current input event as the action of taking inventory;<br>&nbsp;&nbsp;&nbsp;&nbsp; accept the input event.</font></blockquote>
<p>
 (Note that a stored action is always phrased &quot;the action of...&quot;.)
<p>
 See example: &quot;A Study In Memoriam&quot;.
<p>
 By the way, at the handling-input stage, all inputs have been completed or cancelled. You don't have to worry about manually interrupting text input.
<p>
 Section: Which rulebook again?
<p>
 The accepting-input and handling-input rulebooks both operate on input events. They both can accept and reject events. When you're building a game, you may find yourself unsure which to use.
<p>
 The rules of thumb:
<p>
 - If you want to generate an action, use a handling input rule.
<p>
 - If you want to convert some event into a line input event, you can use either, but handling input will probably be simpler.
<p>
 - If you want to respond to an event without interrupting the player's input, use an accepting input rule.
<p>
 - If you want to reject an event without even printing a new prompt, use an accepting input rule.
<p>
 - If you want to respond to events in every input context (including yes-or-no, keystroke-wait, etc) use an accepting input rule.
<p>
 Section: What about the reading a command activity?
<p>
 The old &quot;reading a command&quot; activity still exists under UGI. It's called by the same code that runs the handling input rulebook. It's not the same thing, though; we must be careful of the differences.
<p>
 - Reading a command is an activity. You can write before rules and after rules for it. The accepting input and handling input rulebooks run &quot;inside&quot; reading a command -- between the before and after stages of the activity.
<p>
 - In an after reading a command rule, you can refer to (or replace) the &quot;player's command&quot; snippet. That's not allowed in a handling input rule; the player's command is not yet set up during that rulebook.
<p>
 - In a handling input rule, you can say &quot;handle the current input event as the action of...&quot;. That's not available at after reading a command time.
<p>
 - For a disambiguation input, the handling input rule sees what the player typed. In contrast, the player's command (in an after reading a command rule) is the *entire* disambiguated command! An example:
<p>
<blockquote><font color="#000080"> &gt;GET<br> (handling input: text=&quot;GET&quot;.)<br> (after reading: player's command=&quot;GET&quot;.)<br> What do you want to get?<br> &gt;RED ROCK<br> (handling input: text=&quot;RED ROCK&quot;.)<br> (after reading: player's command=&quot;GET RED ROCK&quot;.)<br> Taken.</font></blockquote>
<p>
 In short, the reading a command activity is the most sensible place to examine or replace text. The handling input rulebook is primarily meant for translating *non-textual* input events into actions.
<p>
 Chapter: The flow of the machinery
<p>
 It may be helpful to diagram the whole input machine and describe exactly when each rulebook runs.
<p>
<blockquote><font color="#000080"> (top of parser loop:)<br> do before reading a command activity<br> repeat until a command is accepted:<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp; (ParserInput function:)<br>&nbsp;&nbsp;&nbsp;&nbsp; repeat until an event is accepted:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; follow setting up input rules<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (AwaitInput function:)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repeat until an event is accepted:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; follow prompt displaying rules<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; redraw the status line<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; make all necessary Glk input requests<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wait for an input event to arrive<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; follow the accepting input rules<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cancel any remaining Glk input requests<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (end of AwaitInput function)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reject blank lines (&quot;I beg your pardon&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if the setting-up rules said that this is an undoable turn:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; follow checking undo input rules<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if the input was an UNDO command:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perform UNDO<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; save an undo point<br>&nbsp;&nbsp;&nbsp;&nbsp; (end of ParserInput function)<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp; follow handling input rules<br> (at this point, the &quot;player's command&quot; is set)<br> do after reading a command activity<br> if no action is recognized, say &quot;I beg your pardon&quot;<br> otherwise, carry out the action</font></blockquote>
<p>
 Requests such as &quot;player consents&quot; and &quot;wait for any key&quot; only invoke the AwaitInput function. They bypass ParserInput, and thus ignore the setting up input rules and the handling input rules.
<p>
 The inner blank-line rejection is a bit of an anomaly. It happens before the handling input rules (and the after reading a command activity), which may cause problems; you cannot handle blank line input the same way you handle other line input.
<p>
 UGI offers a use option to resolve this:
<p>
<blockquote><font color="#000080"> Use pass blank input lines.</font></blockquote>
<p>
 If you set this, the reject blank lines step is omitted. A blank line will pass through all the same rulebooks as other line input. It will be rejected at the *last* step -- no action is recognized, say &quot;I beg your pardon&quot;. So the player will see the same response, really.
<p>
 (One difference: we will have passed through the save-undo step. That is, when this option is set, blank lines count as undoable commands. That's not great, but it's not a big nuisance either. A future version of UGI may address this.)
<p>
 Chapter: Low-level invocations
<p>
 UGI offers phrases to stop and wait for a particular input (a keystroke, a yes-or-no question). It's quite easy to write your own such phrase.
<p>
 Say we want to stop and wait for one hyperlink click. First we'll want to define a new input-context:
<p>
<blockquote><font color="#000080"> Link-wait context is an input-context.</font></blockquote>
<p>
 Then we need a rule to accept hyperlink input, storing the link value in a global:
<p>
<blockquote><font color="#000080"> The found object is an object that varies.<br> Rule for accepting input for link-wait context when handling hyperlink-event:<br>&nbsp;&nbsp;&nbsp;&nbsp; now the found object is the current input event hyperlink object;<br>&nbsp;&nbsp;&nbsp;&nbsp; accept the input event.</font></blockquote>
<p>
 Now we can write a phrase:
<p>
<blockquote><font color="#000080"> To decide what object is the hyperlink waited for:<br>&nbsp;&nbsp;&nbsp;&nbsp; now the found object is nothing;<br>&nbsp;&nbsp;&nbsp;&nbsp; clear all input requests;<br>&nbsp;&nbsp;&nbsp;&nbsp; now the story-window is hyperlink-input-request;<br>&nbsp;&nbsp;&nbsp;&nbsp; await input in link-wait context;<br>&nbsp;&nbsp;&nbsp;&nbsp; decide on the found object.</font></blockquote>
<p>
 The core phrase here is
<p>
<blockquote><font color="#000080"> await input in (C - input-context)</font></blockquote>
<p>
 Before calling this, we *must* set the desired request properties. (Remember, the setting up input rulebook will not be run) It is best to clear all requests and then set exactly the requests desired.
<p>
 If we want line input, we must use one of the alternate forms:
<p>
<blockquote><font color="#000080"> await input in (C - input-context) with primary buffer<br> await input in (C - input-context) with secondary buffer</font></blockquote>
<p>
 Generally you will want to use the secondary buffer. That will avoid stomping on the player's command (which is always stored in the primary buffer).
<p>
 For another case, see example: &quot;Secret Number Request&quot;
<p>
 Chapter: TEST ME
<p>
 Inform's standard TEST ME facility has been upgraded to support more kinds of events. You can now say
<p>
<blockquote><font color="#000080"> Test me with &quot;$char x / $char 65 / $char escape / $char&quot;.<br> Test me with &quot;$link 123 / $link sword&quot;.<br> Test me with &quot;$timer&quot;.</font></blockquote>
<p>
 Any test line beginning with a dollar sign defines a special event. You can escape dollar signs and slashes in line input by writing &quot;[$]&quot; or &quot;[/]&quot;.
<p>
 Character (keystroke) events are defined with &quot;$char&quot;; they can be single characters, ASCII codes, or special names such as &quot;escape&quot;, &quot;left&quot;, &quot;right&quot;, &quot;space&quot;, etc. &quot;$char&quot; by itself is taken as a space keystroke.
<p>
 (Note that Inform automatically lower-cases test lines. So to define an upper-case keystroke, you must use a numeric ASCII code.)
<p>
 Hyperlink events are defined with &quot;$link&quot;; they can be a numeric value or an object name. Note that the object name parsing is extremely simplistic. Only one word is recognized after &quot;$link&quot;, and it must be unconditionally defined for the object (not a property adjective, e.g.). There is no disambiguation; if several objects match the word, the test just picks the first one.
<p>
 Timer events are defined with &quot;$timer&quot;. There is no other information to supply.
<p>
 If you generate a test event that the game isn't expecting, it will be ignored and the game will move on to the next test.
<p>
 Chapter: Under the hood
<p>
 This chapter describes what UGI has changed in the deep reaches of the Parser.i6t template. It is not very interesting.
<p>
 The low-level functions VM_ReadKeyboard and VM_KeyDelay are gone. Instead, AwaitInput handles the bottom-level glk_select loop. Where VM_ReadKeyboard took two arguments (buffer and table), AwaitInput takes four (input-context, event, buffer, table).
<p>
 Responsibility for redrawing the status line and printing the prompt has been moved into AwaitInput. (In the old model, these had to be done before calling an input function, meaning they were required in a lot of places. Bugs resulted.)
<p>
 The old Keyboard routine has been renamed ParserInput. It too now takes input-context, event, buffer, and table arguments. ParserInput is a wrapper around AwaitInput which adds OOPS and UNDO support.
<p>
 Blank line rejection is still handled in ParserInput (nee Keyboard), but only for the sake of backwards compatibility. By using the &quot;pass blank input lines&quot; option, the game can omit this check from ParserInput. Blank lines are then handled the same way as all other line input (and rejected by the parser at a later stage).
<p>
 TestKeyboardPrimitive (in Tests.i6t) is now named CheckTestInput. It now takes event and buffer arguments. (Not table, as tokenization is now handled by the caller.)
<p>
 Responsibility for getting TEST ME input (the CheckTestInput call) has been moved into AwaitInput, right next to the code that gets REPLAY stream input. CheckTestInput returns a flag indicating whether it generated a test event. (This is different from TestKeyboardPrimitive, which was called from the KeyboardPrimitive wrapper, and called through to VM_ReadKeyboard when no test event was available. KeyboardPrimitive is not needed in the new model.)
<p>
 The parser itself used to call Keyboard in three places (Parser Letter A and NounDomain). It now calls ParserInput, and understands that it could receive any kind of input event (not just line input).
<p>
 The parser invokes the handling input rulebook after each ParserInput call. If that rulebook generates an action, Parser__parse returns immediately (or NounDomain returns REPARSE_CODE, which leads to the same outcome.) Then the parser rejects blank lines and non-text inputs with an &quot;I beg your pardon&quot; error. After that, we know we have non-blank text input, so parsing proceeds in the original path.
<p>
 Example: * Changing the Prompt - Changing the command prompt in various contexts.
<p>
 The old &quot;command prompt&quot; global variable still works, but we'd like a more rule-based approach. Here we use &quot;What now?&quot; for the command prompt (both primary and disambiguation) and &quot;Answer now!&quot; for the final question.
<p>
 We also use an extended form of the &quot;player consents&quot; phrase, in which we supply the prompt question to use.
<p>
<blockquote><font color="#000080"><img border=0 src=../../../doc_images/paste.png> &quot;Changing the Prompt&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Include Unified Glulx Input by Andrew Plotkin.</font></blockquote>
<p>
<blockquote><font color="#000080"> Prompt displaying rule for a command input-context:<br>&nbsp;&nbsp;&nbsp;&nbsp; instead say &quot;What now? &quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> Prompt displaying rule for the final question context:<br>&nbsp;&nbsp;&nbsp;&nbsp; instead say &quot;Answer now! &quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> The Kitchen is a room. &quot;You are in a kitchen.&quot;<br> The Outdoors is outside from the Kitchen.</font></blockquote>
<p>
<blockquote><font color="#000080"> Check going outside:<br>&nbsp;&nbsp;&nbsp;&nbsp; if the player consents asking &quot;Outdoors is scary. Are you sure?&quot; and &quot;That was a yes/no question.&quot;:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instead end the story finally;<br>&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instead say &quot;You fail to overcome your agoraphobia.&quot;;</font></blockquote>
<p>
<blockquote><font color="#000080"> Test me with &quot;out / maybe / no / out / yes&quot;.</font></blockquote>
<p>
 Example: ** Tick Tick Tick Button - A timer in the status window.
<p>
 This timer updates a clock in the status window. It never interrupts input or writes to the story window, so we only need an accepting input rule. The rule does its work and then rejects the event. (Timer events are rejected by default, so that last line isn't necessary, but it keeps the flow clear.)
<p>
 The rule doesn't specify an input-context; timer input operates in all contexts. Thus, the clock keeps running during the yes-or-no question. It would keep running even during the game's final question if we didn't switch it off.
<p>
<blockquote><font color="#000080"><img border=0 src=../../../doc_images/paste.png> &quot;Tick Tick Tick Button&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Include Unified Glulx Input by Andrew Plotkin.</font></blockquote>
<p>
<blockquote><font color="#000080"> The Observation Lounge is a room. &quot;This room overlooks the test chamber. A single button is ready to launch the experiment.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> A digital clock is fixed in place in the Lounge. &quot;A digital clock blinks impassively overhead.&quot;<br> The description is &quot;The clock reads [readout].&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> A button is scenery in the Lounge.</font></blockquote>
<p>
<blockquote><font color="#000080"> Check pushing the button:<br>&nbsp;&nbsp;&nbsp;&nbsp; if the player consents asking &quot;Are you very very sure?&quot;:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;[line break]It is now [readout]. The experiment [one of]succeeds[or]fails[purely at random].&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set the timer off;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instead end the story finally;<br>&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instead say &quot;You demur for now.&quot;;</font></blockquote>
<p>
<blockquote><font color="#000080"> When play begins:<br>&nbsp;&nbsp;&nbsp;&nbsp; now the right hand status line is &quot;[readout]&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; set the timer to 1 second.</font></blockquote>
<p>
<blockquote><font color="#000080"> Rule for accepting input when handling timer-event:<br>&nbsp;&nbsp;&nbsp;&nbsp; increment the counter;<br>&nbsp;&nbsp;&nbsp;&nbsp; redraw the status line;<br>&nbsp;&nbsp;&nbsp;&nbsp; reject input event.</font></blockquote>
<p>
<blockquote><font color="#000080"> The counter is initially 60.</font></blockquote>
<p>
<blockquote><font color="#000080"> To say readout:<br>&nbsp;&nbsp;&nbsp;&nbsp; let M be the remainder after dividing the counter by 60;<br>&nbsp;&nbsp;&nbsp;&nbsp; let H be the counter divided by 60;<br>&nbsp;&nbsp;&nbsp;&nbsp; if H &lt; 10:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;0&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; say H;<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;:&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; if M &lt; 10:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;0&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; say M;</font></blockquote>
<p>
 Example: *** Master Blaster - A timer that triggers a game action.
<p>
 In this game, the BLAST command causes an explosion exactly two seconds later.
<p>
 We want the timer to interrupt player input, so we accept the timer event. The interrupt text input line is not required; UGI always interrupts all input when an event is accepted. But by invoking it explicitly with the &quot;preserving input&quot; option, we ensure that the player's interrupted command will be preloaded into the next input line. It also allows us to print a quick &quot;Interrupting...&quot; message before the rule finishes.
<p>
 Note that we only accept timer events when in a command input-context. In any other context (yes-or-no, etc) we would want to ignore the event -- it wouldn't make sense to trigger one game action in the middle of another. (In fact, the handling input rules don't even run in non-command contexts, so the event would be wasted anyhow.)
<p>
 Once the timer event is accepted, it proceeds to the next rulebook, the handling input rules. The rule here generates an explosioning action. (This is a special action which has no understand lines. It cannot be invoked directly by the player; the handling input rule is the only way the explosioning can occur.)
<p>
<blockquote><font color="#000080"><img border=0 src=../../../doc_images/paste.png> &quot;The Master Blaster&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Include Unified Glulx Input by Andrew Plotkin.</font></blockquote>
<p>
<blockquote><font color="#000080"> The Repository is a room. &quot;You are in an immense room, even larger than the giant room. A sign reads, 'Say BLAST to wrap it all up!'&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> The gap is a thing. &quot;A ragged gap in the south wall shows the way to victory!&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Check entering the gap:<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;You march through in triumph.&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; turn the timer off;<br>&nbsp;&nbsp;&nbsp;&nbsp; instead end the story finally.</font></blockquote>
<p>
<blockquote><font color="#000080"> Check going south in the Repository:<br>&nbsp;&nbsp;&nbsp;&nbsp; if the gap is in the Repository:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instead try entering the gap.</font></blockquote>
<p>
<blockquote><font color="#000080"> Blasting is an action applying to nothing.</font></blockquote>
<p>
<blockquote><font color="#000080"> Understand &quot;blast&quot; as blasting.</font></blockquote>
<p>
<blockquote><font color="#000080"> Carry out blasting:<br>&nbsp;&nbsp;&nbsp;&nbsp; if the timer is active:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instead say &quot;The explosion is already on its way.&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; set the timer to 2 seconds;<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;You say the magic word. The air prickles. Wait for it...&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Check answering someone that &quot;blast&quot;:<br>&nbsp;&nbsp;&nbsp;&nbsp; instead try blasting.</font></blockquote>
<p>
<blockquote><font color="#000080"> Explosioning is an action applying to nothing.</font></blockquote>
<p>
<blockquote><font color="#000080"> Carry out explosioning:<br>&nbsp;&nbsp;&nbsp;&nbsp; if the gap is not in the Repository:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now the gap is in the Repository;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now the gap is fixed in place;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instead say &quot;A tremendous explosion rocks the Repository! When the dust clears, you see a gap to the south.&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;Additional fireworks go off! No new gaps though.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Rule for accepting input for a command input-context when handling timer-event:<br>&nbsp;&nbsp;&nbsp;&nbsp; interrupt text input for the story-window, preserving input;<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;(Interrupting...)&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; accept input event.</font></blockquote>
<p>
<blockquote><font color="#000080"> Rule for handling input for a command input-context when handling timer-event:<br>&nbsp;&nbsp;&nbsp;&nbsp; turn the timer off;<br>&nbsp;&nbsp;&nbsp;&nbsp; handle the current input event as the action of explosioning.</font></blockquote>
<p>
<blockquote><font color="#000080"> Test me with &quot;blast / $timer / blast / blast / $timer / south&quot;.</font></blockquote>
<p>
 Example: ** Maze of Keys - Controlling the game with single keystrokes.
<p>
 In this example, the underworld uses a different input mechanism: single keystrokes. Character events are translated into line input for the parser. (This is a crude approach. See the &quot;Maze of Keys 2&quot; example for a tidier model.)
<p>
<blockquote><font color="#000080"><img border=0 src=../../../doc_images/paste.png> &quot;Maze of Keys&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Include Unified Glulx Input by Andrew Plotkin.<br> Include Unicode Character Names by Graham Nelson.</font></blockquote>
<p>
<blockquote><font color="#000080"> The Kitchen is a room. &quot;You are in a kitchen. An open trap door beckons you downward.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Aboveground is a region. The Kitchen is in Aboveground.</font></blockquote>
<p>
<blockquote><font color="#000080"> Maze10 is a room. &quot;You are in a maze of twisty passages, basically all alike.&quot;<br> Maze20 is a room. &quot;You are in a maze of twisty passages, all pretty much alike.&quot;<br> Maze01 is a room. &quot;You are in a maze of twisty passages, all basically alike.&quot;<br> Maze11 is a room. &quot;You are in a maze of twisty passages, all kind of alike.&quot;<br> Maze21 is a room. &quot;You are in a maze of twisty passages, more or less all alike.&quot;<br> Maze02 is a room. &quot;You are in a maze of twisty passages, pretty much all alike.&quot;<br> Maze12 is a room. &quot;You are in a maze of twisty passages, all alike.&quot;<br> Maze22 is a room. &quot;You are in a maze of twisty passages, all more or less alike.&quot;<br> Maze32 is a room. &quot;You are in a maze of twisty passages, all sort of alike.&quot;<br> Maze03 is a room. &quot;You are in a maze of twisty passages, kind of all alike.&quot;<br> Maze13 is a room. &quot;You are in a maze of twisty passages, all quite alike.&quot;<br> Maze23 is a room. &quot;You are in a maze of twisty passages, quite all alike.&quot;<br> Maze33 is a room. &quot;You are in a maze of twisty passages, sort of all alike.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Maze12 is below the Kitchen.<br> Maze10 is west of Maze20.<br> Maze10 is north of Maze11. Maze20 is north of Maze21.<br> Maze01 is west of Maze11. Maze11 is west of Maze21.<br> Maze01 is north of Maze02. Maze11 is north of Maze12.<br> Maze02 is west of Maze12. Maze12 is west of Maze22. Maze22 is west of Maze32.<br> Maze12 is north of Maze13. Maze22 is north of Maze23. Maze32 is north of Maze33.<br> Maze03 is west of Maze13. Maze23 is west of Maze33.</font></blockquote>
<p>
<blockquote><font color="#000080"> Rule for printing the name of a room (called R) when R is not in Aboveground:<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;Maze&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> Check going down from the Kitchen:<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;(Down here, single-keystroke commands rule. Use the arrow keys or NSEW to move around; Z to undo; U or escape to return upstairs.)&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; continue the action.</font></blockquote>
<p>
<blockquote><font color="#000080"> Check going up when the location is not in Aboveground:<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;You fumble your way back to the light.&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; now the player is in the Kitchen;<br>&nbsp;&nbsp;&nbsp;&nbsp; stop the action.</font></blockquote>
<p>
<blockquote><font color="#000080"> Prompt displaying rule when the location is not in Aboveground:<br>&nbsp;&nbsp;&nbsp;&nbsp; instead say &quot;==&gt;&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> Setting up input rule when the location is not in Aboveground:<br>&nbsp;&nbsp;&nbsp;&nbsp; now the input-request of the story-window is char-input;<br>&nbsp;&nbsp;&nbsp;&nbsp; set input undoable;<br>&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds.</font></blockquote>
<p>
<blockquote><font color="#000080"> Accepting input rule when the location is not in Aboveground and handling char-event:<br>&nbsp;&nbsp;&nbsp;&nbsp; let C be the current input event character;<br>&nbsp;&nbsp;&nbsp;&nbsp; if C is special keycode left or C is Unicode Latin small letter w or C is Unicode Latin capital letter W:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;GO WEST[line break]&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; replace the current input event with the line &quot;go west&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds;<br>&nbsp;&nbsp;&nbsp;&nbsp; if C is special keycode right or C is Unicode Latin small letter e or C is Unicode Latin capital letter E:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;GO EAST[line break]&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; replace the current input event with the line &quot;go east&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds;<br>&nbsp;&nbsp;&nbsp;&nbsp; if C is special keycode up or C is Unicode Latin small letter n or C is Unicode Latin capital letter N:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;GO NORTH[line break]&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; replace the current input event with the line &quot;go north&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds;<br>&nbsp;&nbsp;&nbsp;&nbsp; if C is special keycode down or C is Unicode Latin small letter s or C is Unicode Latin capital letter S:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;GO SOUTH[line break]&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; replace the current input event with the line &quot;go south&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds;<br>&nbsp;&nbsp;&nbsp;&nbsp; if C is special keycode escape or C is Unicode Latin small letter u or C is Unicode Latin capital letter U:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;GO UP[line break]&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; replace the current input event with the line &quot;go up&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds;<br>&nbsp;&nbsp;&nbsp;&nbsp; if C is Unicode Latin small letter l or C is Unicode Latin capital letter L:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;LOOK[line break]&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; replace the current input event with the line &quot;look&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds;<br>&nbsp;&nbsp;&nbsp;&nbsp; if C is Unicode Latin small letter z or C is Unicode Latin capital letter Z:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;UNDO[line break]&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; replace the current input event with the line &quot;undo&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds;<br>&nbsp;&nbsp;&nbsp;&nbsp; interrupt text input for the story-window;<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;('[extended C]' is not a valid key.)&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; reject the input event.</font></blockquote>
<p>
<blockquote><font color="#000080"> Test me with &quot;down / $char s / $char w / $char right / $char up / $char escape / look&quot;.</font></blockquote>
<p>
 Example: *** Maze of Keys 2 - Controlling the game with single keystrokes.
<p>
 This is nearly the same as the previous example. But now, instead of changing char input events to line input events, we handle char events directly as going actions.
<p>
 The work is now done in the accepting input rulebook. We no longer pretend that we're entering line input, and the parser is entirely bypassed.
<p>
<blockquote><font color="#000080"><img border=0 src=../../../doc_images/paste.png> &quot;Maze of Keys 2&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Include Unified Glulx Input by Andrew Plotkin.<br> Include Unicode Character Names by Graham Nelson.</font></blockquote>
<p>
<blockquote><font color="#000080"> The Kitchen is a room. &quot;You are in a kitchen. An open trap door beckons you downward.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Aboveground is a region. The Kitchen is in Aboveground.</font></blockquote>
<p>
<blockquote><font color="#000080"> Maze10 is a room. &quot;You are in a maze of twisty passages, basically all alike.&quot;<br> Maze20 is a room. &quot;You are in a maze of twisty passages, all pretty much alike.&quot;<br> Maze01 is a room. &quot;You are in a maze of twisty passages, all basically alike.&quot;<br> Maze11 is a room. &quot;You are in a maze of twisty passages, all kind of alike.&quot;<br> Maze21 is a room. &quot;You are in a maze of twisty passages, more or less all alike.&quot;<br> Maze02 is a room. &quot;You are in a maze of twisty passages, pretty much all alike.&quot;<br> Maze12 is a room. &quot;You are in a maze of twisty passages, all alike.&quot;<br> Maze22 is a room. &quot;You are in a maze of twisty passages, all more or less alike.&quot;<br> Maze32 is a room. &quot;You are in a maze of twisty passages, all sort of alike.&quot;<br> Maze03 is a room. &quot;You are in a maze of twisty passages, kind of all alike.&quot;<br> Maze13 is a room. &quot;You are in a maze of twisty passages, all quite alike.&quot;<br> Maze23 is a room. &quot;You are in a maze of twisty passages, quite all alike.&quot;<br> Maze33 is a room. &quot;You are in a maze of twisty passages, sort of all alike.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Maze12 is below the Kitchen.<br> Maze10 is west of Maze20.<br> Maze10 is north of Maze11. Maze20 is north of Maze21.<br> Maze01 is west of Maze11. Maze11 is west of Maze21.<br> Maze01 is north of Maze02. Maze11 is north of Maze12.<br> Maze02 is west of Maze12. Maze12 is west of Maze22. Maze22 is west of Maze32.<br> Maze12 is north of Maze13. Maze22 is north of Maze23. Maze32 is north of Maze33.<br> Maze03 is west of Maze13. Maze23 is west of Maze33.</font></blockquote>
<p>
<blockquote><font color="#000080"> Rule for printing the name of a room (called R) when R is not in Aboveground:<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;Maze&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> Check going down from the Kitchen:<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;(Down here, single-keystroke commands rule. Use the arrow keys or NSEW to move around; Z to undo; U or escape to return upstairs.)&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; continue the action.</font></blockquote>
<p>
<blockquote><font color="#000080"> Check going up when the location is not in Aboveground:<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;You fumble your way back to the light.&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; now the player is in the Kitchen;<br>&nbsp;&nbsp;&nbsp;&nbsp; stop the action.</font></blockquote>
<p>
<blockquote><font color="#000080"> Prompt displaying rule when the location is not in Aboveground:<br>&nbsp;&nbsp;&nbsp;&nbsp; instead say &quot;==&gt;&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> Setting up input rule when the location is not in Aboveground:<br>&nbsp;&nbsp;&nbsp;&nbsp; now the input-request of the story-window is char-input;<br>&nbsp;&nbsp;&nbsp;&nbsp; set input undoable;<br>&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds.</font></blockquote>
<p>
<blockquote><font color="#000080"> Checking undo input rule when the location is not in Aboveground:<br>&nbsp;&nbsp;&nbsp;&nbsp; let C be the current input event character;<br>&nbsp;&nbsp;&nbsp;&nbsp; if C is Unicode Latin small letter z or C is Unicode Latin capital letter Z:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;(Undoing one turn...)&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds.</font></blockquote>
<p>
<blockquote><font color="#000080"> Handling input rule when the location is not in Aboveground and handling char-event:<br>&nbsp;&nbsp;&nbsp;&nbsp; let C be the current input event character;<br>&nbsp;&nbsp;&nbsp;&nbsp; if C is special keycode left or C is Unicode Latin small letter w or C is Unicode Latin capital letter W:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;(You try going west...)&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle the current input event as the action of going west;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds;<br>&nbsp;&nbsp;&nbsp;&nbsp; if C is special keycode right or C is Unicode Latin small letter e or C is Unicode Latin capital letter E:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;(You try going east...)&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle the current input event as the action of going east;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds;<br>&nbsp;&nbsp;&nbsp;&nbsp; if C is special keycode up or C is Unicode Latin small letter n or C is Unicode Latin capital letter N:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;(You try going north...)&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle the current input event as the action of going north;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds;<br>&nbsp;&nbsp;&nbsp;&nbsp; if C is special keycode down or C is Unicode Latin small letter s or C is Unicode Latin capital letter S:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;(You try going south...)&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle the current input event as the action of going south;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds;<br>&nbsp;&nbsp;&nbsp;&nbsp; if C is special keycode escape or C is Unicode Latin small letter u or C is Unicode Latin capital letter U:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;(You try going up...)&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle the current input event as the action of going up;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds;<br>&nbsp;&nbsp;&nbsp;&nbsp; if C is Unicode Latin small letter l or C is Unicode Latin capital letter L:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;(You look around...)&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle the current input event as the action of looking;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds;<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;('[extended C]' is not a valid key.)&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; reject the input event.</font></blockquote>
<p>
<blockquote><font color="#000080"> Test me with &quot;down / $char s / $char w / $char right / $char up / $char escape / look&quot;.</font></blockquote>
<p>
 Example: ** A Study In Memoriam - A pure-hyperlink game.
<p>
 Here we drop text input entirely. (Dropping the standard parser input line request rule accomplishes this.) Instead we set up input to be hyperlink-based. Hyperlink events are translated into the examining action, which happily works for both on-stage objects and off-stage memories.
<p>
<blockquote><font color="#000080"><img border=0 src=../../../doc_images/paste.png> &quot;A Study In Memoriam&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Include Unified Glulx Input by Andrew Plotkin.</font></blockquote>
<p>
<blockquote><font color="#000080"> The Study is a room. &quot;You are in your cluttered study.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> The messy desk is a supporter in the Study. The description is &quot;You found this battered antique in a battered [antique shop] in Chapel Hill. As you recall, it was sitting behind [a microscope].&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> A fossil is on the desk. The description is &quot;Some species of [ammonite].&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> A copper fulgurite is on the desk. The description is &quot;It's a chunk of melted copper that you picked up from the base of a telephone pole. It's not really fulgurite, minerallogically speaking. But it [italic type]was[roman type] formed by [lightning]!&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> A memory is a kind of thing.</font></blockquote>
<p>
<blockquote><font color="#000080"> The ammonite is a memory. The description is &quot;You've dreamed of drifting through antediluvian seas, the master of all you survey... Then the bony fishes come. The damned bony fishes.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> The microscope is a memory. The printed name is &quot;defunct electron microscope&quot;. The description is &quot;Yes, you once discovered an electron microsope in [an antique shop]. It was a console device, like a kitchen counter with switches all over the top and vacuum pumps hanging out underneath. You wonder if anyone ever purchased it.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> The antique shop is a memory. The description is &quot;You discovered a mad antique shop on a years-ago trip to North Carolina. The prize of its collection was [a microscope], though you doubt anyone else would think of it that way. You bought [hyperlink desk]an old desk[/hyperlink] instead; the very one in this room.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> The lightning is a memory. The description is &quot;One can never remember lightning properly.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Rule for printing the name of an object (called O):<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;[hyperlink O][printed name of O][/hyperlink]&quot;;</font></blockquote>
<p>
<blockquote><font color="#000080"> The standard parser input line request rule does nothing.</font></blockquote>
<p>
<blockquote><font color="#000080"> Prompt displaying rule for a command input-context:<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;[first time](Touch a link.)[only]&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds.</font></blockquote>
<p>
<blockquote><font color="#000080"> Setting up input rule:<br>&nbsp;&nbsp;&nbsp;&nbsp; now the story-window is hyperlink-input-request.</font></blockquote>
<p>
<blockquote><font color="#000080"> Handling input rule for a command input-context when handling hyperlink-event:<br>&nbsp;&nbsp;&nbsp;&nbsp; let O be current input event hyperlink object;<br>&nbsp;&nbsp;&nbsp;&nbsp; if O is nothing:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reject the input event;<br>&nbsp;&nbsp;&nbsp;&nbsp; if O is a room:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle the current input event as the action of looking;<br>&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle the current input event as the action of examining O;<br>&nbsp;&nbsp;&nbsp;&nbsp; rule succeeds.</font></blockquote>
<p>
<blockquote><font color="#000080"> Before examining something:<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;--- [The noun] ---[paragraph break]&quot;;</font></blockquote>
<p>
<blockquote><font color="#000080"> Section - not for release</font></blockquote>
<p>
<blockquote><font color="#000080"> The test-me is a memory.</font></blockquote>
<p>
<blockquote><font color="#000080"> When play begins:<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;(Hit [test-me] to run the tests.)&quot;;</font></blockquote>
<p>
<blockquote><font color="#000080"> Instead of examining test-me:<br>&nbsp;&nbsp;&nbsp;&nbsp; run test-me.</font></blockquote>
<p>
<blockquote><font color="#000080"> To run test-me: (-  special_word = 'me//'; TestScriptSub();  -).</font></blockquote>
<p>
<blockquote><font color="#000080"> Test me with &quot;$link fossil / $link ammonite / $link study&quot;.</font></blockquote>
<p>
 Example: **** Secret Number Request - A phrase to query the player for a number.
<p>
 In this example we ask the player for a number. It's very much like &quot;if the player consents...&quot; except that we get back a number rather than a yes-or-no decision.
<p>
 We'll want a new input-context for this operation, so we invent one: numeric context. Our prompt displaying rule relies on this to give the player a special prompt for the number-typing operation.
<p>
 The &quot;number waited for&quot; phrase demonstrates doing a low-level input operation. First we must clear all input requests for the story window. (We don't want a request left over from regular command input.) Then we set the input request we want -- line input only. Then we &quot;await input&quot;, using our special numeric context.
<p>
 Then it gets a little bit messy. There's no easy I7 access to the input buffer. We can't use &quot;the player's command&quot; because that's a parser variable. We're doing this behind the parser's back, so no player's command is ever set. Nor can we match against an I7 token like &quot;[number]&quot;.
<p>
 Instead, we rely on an existing I6 function called TryNumber. This returns the parsed number, or -1000 if no number was typed. Loop until we get something valid.
<p>
 Unfortunately, TryNumber is set up to use the parser's input buffer. That's why the input phrase is
<p>
<blockquote><font color="#000080"> await input in numeric context with primary buffer;</font></blockquote>
<p>
 This winds up stomping on &quot;the player's command&quot;; that snippet will be invalid for the rest of the turn. Too bad!
<p>
 A better implementation would rely on the secondary buffer. We couldn't use TryNumber, though, so it would be a longer and messier example.
<p>
<blockquote><font color="#000080"><img border=0 src=../../../doc_images/paste.png> &quot;Secret Number Request&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Include Unified Glulx Input by Andrew Plotkin.</font></blockquote>
<p>
<blockquote><font color="#000080"> The Alley is a room. &quot;You are in that alley from that spy game. A steel door is to the east; next to it is a button and a speaker grille.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> The steel door is scenery in the Alley. The description is &quot;The door is closed and locked.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> Check entering the steel door:<br>&nbsp;&nbsp;&nbsp;&nbsp; instead say &quot;The door isn't open.&quot;<br> Check going east in the Alley:<br>&nbsp;&nbsp;&nbsp;&nbsp; instead try entering the steel door.<br> Check going south in the Alley:<br>&nbsp;&nbsp;&nbsp;&nbsp; instead say &quot;You can't quit now.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> The secret number is initially 0.</font></blockquote>
<p>
<blockquote><font color="#000080"> The button is scenery in the Alley.</font></blockquote>
<p>
<blockquote><font color="#000080"> Check pushing the button:<br>&nbsp;&nbsp;&nbsp;&nbsp; if the secret number is 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now the secret number is a random number between 100 and 500;<br>&nbsp;&nbsp;&nbsp;&nbsp; say &quot;A crackly voice asks, 'What's the secret number?'&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; let N be the number waited for;<br>&nbsp;&nbsp;&nbsp;&nbsp; if N is the secret number:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;'Did you say [N]? You're right!' The door pops open and someone on the other side tasers you.&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end the story finally;<br>&nbsp;&nbsp;&nbsp;&nbsp; else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;'Did you say [N]? That's not right. The secret number today is [secret number].'[paragraph break]The door does not open.&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp; stop the action.</font></blockquote>
<p>
<blockquote><font color="#000080"> Numeric context is an input-context.</font></blockquote>
<p>
<blockquote><font color="#000080"> Prompt displaying rule for numeric context:<br>&nbsp;&nbsp;&nbsp;&nbsp; instead say &quot;==&gt;&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> To decide what number is the number waited for:<br>&nbsp;&nbsp;&nbsp;&nbsp; while 1 is 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear all input requests;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now the input-request of the story-window is line-input;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; await input in numeric context with primary buffer;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let N be the hacky low-level number check;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if N is not -1000:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decide on N;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; say &quot;Please enter a number.&quot;;</font></blockquote>
<p>
<blockquote><font color="#000080"> To decide what number is the hacky low-level number check: (-  TryNumber(1)  -).</font></blockquote>
<p>

<p>
<p></body></html>