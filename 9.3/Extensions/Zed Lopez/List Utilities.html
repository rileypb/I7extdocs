<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Extension</title><script type="text/javascript">	function showExtra(id, imid) {		if (document.getElementById(id).style.display == 'block') {			document.getElementById(id).style.display = 'none';			document.getElementById(imid).src = 'inform:/extra.png';		} else {			document.getElementById(id).style.display = 'block';			document.getElementById(imid).src = 'inform:/extraclose.png';		}	}    function openExtra(id, imid) {    	document.getElementById(id).style.display = 'block';    	document.getElementById(imid).src = 'inform:/extraclose.png';    }    function closeExtra(id, imid) {    	document.getElementById(id).style.display = 'none';    	document.getElementById(imid).src = 'inform:/extra.png';    }</script></head><STYLE TYPE="text/css"><!--*, *:before, *:after {-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;}.oval, .oval TD{background-image:url('../../../doc_images/ovoid.png');color:white;}--></STYLE><body><script language="JavaScript">function pasteCode(code) {    var myProject = window.Project;    myProject.selectView('source');    myProject.pasteCode(code);}</script><font face="lucida grande,geneva,arial,tahoma,verdana,helvetica,helv" size=2><table CELLPADDING=0 CELLSPACING=0 width="100%" bgcolor="#000000"><tr><TD width=38px height=26px align="center" valign="center"><img border=0 src="../../../doc_images/Hookindex.png" border=0></td><TD width=38px height=26px align="center" valign="center"></td><td halign="left" valign="center" CELLPADDING=0 CELLSPACING=0></td><TD width=56px height=26px align="right" valign="center"><img border=0 src="../../../doc_images/Hookup.png" border=0></td></tr></table><p><img border=0 src=../../../doc_images/paste.png>&nbsp;<b>List Utilities<font color="#404040"> by </font>Zed Lopez</b><p><small></small><p><p><hr><p>
<p>
 Chapter Examples
<p>
 Example: ** List tests
<p>
<blockquote><font color="#000080"><img border=0 src=../../../doc_images/paste.png> &quot;List tests&quot;<br> Include List Utilities by Zed Lopez.<br> Include Unit Tests by Zed Lopez.</font></blockquote>
<p>
<blockquote><font color="#000080"> Use test automatically.</font></blockquote>
<p>
<blockquote><font color="#000080"> Lab is a room.</font></blockquote>
<p>
<blockquote><font color="#000080"> emptying is a unit test. &quot;Emptying&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> empty-l is a list of numbers that varies.<br> empty-l is usually { }.<br> ref is always { 0, 1, 2 }.<br> rev-ref is always { 2, 1, 0 }.<br> lol is always { { 0, 1, 2 }, { 0, 2, 1 }, { 1, 0, 2 }, { 1, 2, 0 }, { 2, 0, 1 }, { 2, 1, 0 } }.<br> list9 is always { 1, 2, 3, 4, 5, 6, 7, 8, 9 }.<br> loneliest is always { 1 }.<br> teens is always { 13, 14, 15, 16, 17, 18, 19 }.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing emptying:<br> let L be a list of numbers;<br> empty L;<br> for &quot;emptying an empty list&quot; assert L is empty;<br> let L2 be { 1, 2, 3 };<br> empty L2;<br> for &quot;emptying a non-empty list&quot; assert the number of entries in L2 is 0;</font></blockquote>
<p>
<blockquote><font color="#000080"> Random entry is a unit test. &quot;Random entry&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> test-num is initially 0.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing random entry:<br> let z be a random entry from empty-l;<br> for &quot;random entry from empty list&quot; assert z is 0;<br> for &quot;random entry from empty list error&quot; assert &quot;[test random entry from empty-l is 0]&quot; reports an error;<br> let z2 be a random entry from empty-l or improbable number;<br> for &quot;random entry from empty list or backup&quot; assert z2 is improbable number;<br> let count be { 0, 0, 0 };<br> repeat with i running from 1 to 300 begin;<br> let x be a random entry in ref;<br> increment entry (x + 1) in count;<br> end repeat;<br> let label be &quot;monte carlo [count]&quot;;<br> repeat with i running through ref begin;<br> let j be i + 1;<br> if entry j in count &lt; 50 or entry j in count &gt; 200 begin;<br> for label fail;<br> rule fails;<br> end if;<br> end repeat;<br> for label pass;</font></blockquote>
<p>
<blockquote><font color="#000080"> Shuffle is a unit test. &quot;Returning shuffled list&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing shuffle:<br> let empty-shuffling be shuffled empty-l;<br> for &quot;empty list shuffled&quot; assert empty-shuffling is empty;<br> let count be a list of numbers;<br> let indices be { 6, 8, 12, 16, 20, 22 };<br> extend count to 22 entries;<br> let result be a list of numbers;<br> let orig be { 0, 1, 2 };<br> repeat with i running from 1 to 300 begin;<br> let M be shuffled ref;<br> let val be 1 + (entry 1 of M) + ((entry 2 of M) * 3) + ((entry 3 of M) * 9);<br> now entry val of count is (entry val of count) + 1;<br> end repeat;<br> repeat with i running through indices begin;<br> add entry i of count to result;<br> end repeat;<br> for &quot;Original unchanged&quot; assert orig is { 0, 1, 2 };<br> let label be &quot;Shuffle [result]&quot;;<br> repeat with i running through result begin;<br> if i &lt; 22 or i &gt; 86 begin;<br> for label fail;<br> rule fails;<br> end if;<br> end repeat;<br> for label pass;</font></blockquote>
<p>
<blockquote><font color="#000080"> Sort is a unit test.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing sort:<br> let empty-sorted be sorted empty-l;<br> for &quot;empty list sorted&quot; assert empty-sorted is empty;<br> for &quot;empty list sorted backwards&quot; assert sorted empty-l backwards is empty;<br> repeat with l running through lol begin;<br> let orig be l;<br> for &quot;sort [l]&quot; assert sorted l is ref;<br> unless l is orig, for &quot;sort [l] original changed&quot; fail;<br> for &quot;sort [l] backwards&quot; assert sorted l backwards is rev-ref;<br> end repeat;</font></blockquote>
<p>
<blockquote><font color="#000080"> Reverse is a unit test. &quot;Returning reversed list&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing reverse:<br> let empty-reverse be reverse empty-l;<br> for &quot;empty list reverse&quot; assert empty-reverse is empty;<br> repeat with l running through lol begin;<br> let orig be l;<br> let r be reverse l;<br> let len be number of entries in l;<br> repeat with i running from 1 to len begin;<br> unless entry i of r is entry (len + 1 - i) of l begin;<br> for &quot;sort [r] backwards&quot; fail;<br> rule fails;<br> end unless;<br> end repeat;<br> end repeat;<br> for &quot;sort backwards&quot; pass;</font></blockquote>
<p>
<blockquote><font color="#000080"> Pop value is a unit test. &quot;Pop value&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing pop value:<br> let l1 be ref;<br> let p be pop l1;<br> for &quot;popped value { 0, 1, 2 }, got 2&quot; assert p is 2;<br> for &quot;popped value { 0, 1, 2 }, length of list&quot; assert number of entries in l1 is 2;<br> for &quot;popped value { 0, 1, 2 }, first entry 0&quot; assert entry 1 of l1 is 0;<br> for &quot;popped value { 0, 1, 2 }, second entry 1&quot; assert entry 2 of l1 is 1;<br> for &quot;popped non-empty with backup&quot; assert pop l1 or improbable number is 1;<br> let l2 be a list of numbers;<br> for &quot;popped value empty list&quot; assert pop l2 is 0;<br> for &quot;popped value empty list error&quot; assert &quot;[test pop l2 is 0]&quot; reports error;<br> let l3 be teens;<br> for &quot;popped value non-empty with backup&quot; assert pop l3 or improbable number is 19;<br> let l4 be a list of numbers;<br> for &quot;popped value empty with backup&quot; assert pop l4 or improbable number is improbable number;</font></blockquote>
<p>
<blockquote><font color="#000080"> Pop discarding is a unit test. &quot;Pop, discarding value&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> empty-num-list is a list of numbers that varies.<br> empty-num-list is initially { }.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing pop discarding:<br> let l1 be ref;<br> pop l1;<br> for &quot;popped { 0, 1, 2 }, length of list&quot; assert number of entries in l1 is 2;<br> for &quot;popped { 0, 1, 2 }, first entry&quot; assert entry 1 of l1 is 0;<br> for &quot;popped { 0, 1, 2 }, second entry&quot; assert entry 2 of l1 is 1;<br> for &quot;popped empty list error&quot; assert &quot;[test pop empty-num-list]&quot; reports error;<br> let l2 be a list of numbers;<br> pop l2;<br> for &quot;popped empty list&quot; assert l2 is empty;</font></blockquote>
<p>
<blockquote><font color="#000080"> Push is a unit test. &quot;Push&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing push:<br> let l1 be ref;<br> push 5 on l1;<br> for &quot;pushed 5 on { 0, 1, 2 }, length of list&quot; assert number of entries in l1 is 4;<br> for &quot;pushed 5 on { 0, 1, 2 }, first entry&quot; assert entry 1 of l1 is 0;<br> for &quot;pushed 5 on { 0, 1, 2 }, third entry&quot; assert entry 3 of l1 is 2;<br> for &quot;pushed 5 on { 0, 1, 2 }, fourth entry&quot; assert entry 4 of l1 is 5;<br> let l2 be a list of numbers;<br> push 7 on l2;<br> for &quot;push 7 on {}, length of list&quot; assert number of entries in l2 is 1;<br> for &quot;push 7 on {}, sole entry&quot; assert entry 1 of l2 is 7;</font></blockquote>
<p>
<blockquote><font color="#000080"> Shift value is a unit test. &quot;Shift value&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing shift value:<br> let l1 be ref;<br> let l2 be l1;<br> let p be shift l2;<br> for &quot;shift value { 0, 1, 2 }, got 0&quot; assert p is 0;<br> for &quot;shift value { 0, 1, 2 }, length of list&quot; assert number of entries in l2 is 2;<br> for &quot;shift value { 0, 1, 2 }, first entry&quot; assert entry 1 of l2 is 1;<br> for &quot;shift value { 0, 1, 2 }, second entry&quot; assert entry 2 of l2 is 2;<br> for &quot;shift value, original unchanged&quot; assert l1 is ref;<br> let l2 be teens;<br> for &quot;shifted non-empty with backup&quot; assert (shift l2 or improbable number) is 13;<br> let L be a list of numbers;<br> for &quot;shift value, empty list&quot; assert shift L is 0;<br> for &quot;shift value, empty error message&quot; assert &quot;[test shift empty-num-list]&quot; reports error;</font></blockquote>
<p>
<blockquote><font color="#000080"> Shift discarding is a unit test. &quot;Shift, discarding value&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing shift discarding:<br> let l1 be ref;<br> shift l1;<br> for &quot;shifted { 0, 1, 2 }, length of list&quot; assert number of entries in l1 is 2;<br> for &quot;shifted { 0, 1, 2 }, first entry&quot; assert entry 1 of l1 is 1;<br> for &quot;shifted { 0, 1, 2 }, second entry&quot; assert entry 2 of l1 is 2;<br> let l2 be a list of numbers;<br> shift l2;<br> for &quot;shifted empty list&quot; assert l2 is empty;</font></blockquote>
<p>
<blockquote><font color="#000080"> Unshift is a unit test. &quot;Unshift&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing unshift:<br> let l1 be ref;<br> unshift 5 on l1;<br> for &quot;unshifted 5 on { 0, 1, 2 }, length of list&quot; assert number of entries in l1 is 4;<br> for &quot;unshifted 5 on { 0, 1, 2 }, first entry&quot; assert entry 1 of l1 is 5;<br> for &quot;unshifted 5 on { 0, 1, 2 }, third entry&quot; assert entry 3 of l1 is 1;<br> for &quot;unshifted 5 on { 0, 1, 2 }, fourth entry&quot; assert entry 4 of l1 is 2;<br> let l2 be a list of numbers;<br> unshift 7 on l2;<br> for &quot;unshift 7 on {}, length of list&quot; assert number of entries in l2 is 1;<br> for &quot;unshift 7 on {}, sole entry&quot; assert entry 1 of l2 is 7;</font></blockquote>
<p>
<blockquote><font color="#000080"> Last index is a unit test. &quot;Last index.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing last index:<br> for &quot;empty&quot; assert last index of empty-L is 0;<br> for &quot;last of 9&quot; assert last index of list9 is 9;<br> for &quot;singleton&quot; assert last index of loneliest is 1;</font></blockquote>
<p>
<blockquote><font color="#000080"> Last entry is a unit test. &quot;Last entry.&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing last entry:<br> for &quot;empty&quot; assert last entry of empty-l is 0;<br> for &quot;last of 9&quot; assert last entry of list9 is 9;<br> for &quot;singleton&quot; assert last entry of loneliest is 1;<br> for &quot;rev-ref&quot; assert last entry of rev-ref is 0;</font></blockquote>
<p>
<blockquote><font color="#000080"> Combo is a unit test. &quot;Combination&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing combo:<br> for &quot;empty and list9&quot; refute empty-l is a combination of list9;<br> for &quot;list9 and empty&quot; refute list9 is a combination of empty-l;<br> for &quot;ref and rev-ref&quot; assert rev-ref is a combination of ref;<br> for &quot;shuffled list9s&quot; assert shuffled list9 is a combination of shuffled list9;</font></blockquote>
<p>
<blockquote><font color="#000080"> Uniquity is a unit test. &quot;Uniquity&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing uniquity:<br> for &quot;empty&quot; assert unique empty-l is empty;<br> for &quot;ref&quot; assert sorted unique rev-ref is ref;<br> let duplicative be a list of numbers;<br> repeat for i in 1 to 3 begin;<br> let L be shuffled list9;<br> repeat with j running through L begin;<br> add j to duplicative;<br> end repeat;<br> end repeat;<br> for &quot;duplicative&quot; assert sorted unique duplicative is list9;</font></blockquote>
<p>
<blockquote><font color="#000080"> Intersection is a unit test. &quot;Intersection&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing intersection:<br> for &quot;empty 0&quot; assert intersection of empty-l and empty-l is empty;<br> for &quot;empty 1&quot; assert intersection of empty-l and list9 is empty;<br> for &quot;empty 2&quot; assert intersection of empty-l and loneliest is empty;<br> for &quot;empty 3&quot; assert intersection of loneliest and empty-l is empty;<br> for &quot;ref and loneliest&quot; assert intersection of ref and loneliest is { 1 };<br> for &quot;loneliest and ref&quot; assert intersection of loneliest and ref is { 1 };<br> for &quot;rev-ref and loneliest&quot; assert intersection of rev-ref and loneliest is { 1 };<br> for &quot;list9 and loneliest&quot; assert intersection of list9 and loneliest is { 1 };<br> for &quot;list9 and ref&quot; assert intersection of list9 and ref is { 1, 2 };<br> let lista be shuffled list9;<br> let listb be shuffled list9;<br> let listc be sorted intersection of lista and listb;<br> for &quot;shuffled&quot; assert listc is list9;<br> for &quot;identical&quot; assert intersection of list9 and list9 is list9;</font></blockquote>
<p>
<blockquote><font color="#000080"> Sums is a unit test. &quot;Sums&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing sums:<br> for &quot;empty and ref&quot; assert sum of empty-l and ref is ref;<br> for &quot;rev-ref and empty&quot; assert sum of rev-ref and empty-l is rev-ref;<br> for &quot;empty and empty&quot; assert sum of empty-l and empty-l is empty;<br> for &quot;rev-ref and ref&quot; assert sum of rev-ref and ref is { 2, 1, 0, 0, 1, 2 };<br> for &quot;list9 and list9 length&quot; assert size of sum of list9 and list9 is 18;</font></blockquote>
<p>
<blockquote><font color="#000080"> Union is a unit test. &quot;Union&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing union:<br> for &quot;ref and rev-ref&quot; assert sorted union of ref and rev-ref is ref;<br> for &quot;list9 and ref&quot; assert sorted union of list9 and ref is { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };<br> for &quot;empty and empty&quot; assert union of empty-l and empty-l is empty;<br> for &quot;empty and ref&quot; assert union of empty-l and ref is ref;<br> for &quot;loneliest and teens&quot; assert union of loneliest and teens is { 1, 13, 14, 15, 16, 17, 18, 19 };</font></blockquote>
<p>
<blockquote><font color="#000080"> Intersects is a unit test. &quot;if intersects&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing intersects:<br> for &quot;2 empty lists&quot; refute empty-l intersects empty-l;<br> for &quot;empty lists and ref&quot; refute empty-l intersects ref;<br> for &quot;teens and list9&quot; refute teens intersects list9;</font></blockquote>
<p>
<blockquote><font color="#000080"> Disjoint from is a unit test. &quot;if is disjoint from&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing disjoint from:<br> for &quot;2 empty lists&quot; assert empty-l is disjoint from empty-l;<br> for &quot;empty lists and ref&quot; assert empty-l is disjoint from ref;<br> for &quot;teens and list9&quot; assert teens is disjoint from list9;</font></blockquote>
<p>
<blockquote><font color="#000080"> Slice nice is a unit test. &quot;Slice&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing slice:<br> for &quot;empty&quot; assert entries 3 to 4 of empty-l is empty;<br> for &quot;empty error&quot; assert &quot;[test entries 3 to 4 of empty-l is empty]&quot; reports error;<br> for &quot;plain&quot; assert entries 2 to 3 of list9 is { 2, 3 };<br> for &quot;singleton bottom&quot; assert entries 1 to 1 of list9 is { 1 };<br> for &quot;singleton top&quot; assert entries 9 to 9 of list9 is { 9 };<br> let test-l be list9;<br> for &quot;middle slice&quot; assert entries 3 to 7 of test-l is { 3, 4, 5, 6, 7 };<br> for &quot;original unchanged&quot; assert test-l is list9;<br> for &quot;start slice&quot; assert entries 1 to 3 of test-l is { 1, 2, 3 };<br> for &quot;end slice&quot; assert entries 6 to 9 of test-l is { 6, 7, 8, 9 };<br> for &quot;single slice&quot; assert entries 9 to 9 of test-l is { 9 };<br> for &quot;singleton&quot; assert entries 1 to 1 of loneliest is { 1 };</font></blockquote>
<p>
<blockquote><font color="#000080"> End slice is a unit test. &quot;Slice through end&quot;</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing end slice:<br> for &quot;7 of 9&quot; assert entries 7 to last of list9 is { 7, 8, 9 };<br> for &quot;singleton&quot; assert entries 1 to last of loneliest is { 1 };<br> for &quot;empty&quot; assert entries 1 to 15 of empty-l is empty;<br> for &quot;empty reported error&quot; assert &quot;[test entries 1 to 15 of empty-l is empty]&quot; reports error;</font></blockquote>
<p>
<blockquote><font color="#000080"> Left index is a unit test. &quot;Left index&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing left index:<br> for &quot;empty-l&quot; assert left index of 5 in empty-l is 0;<br> for &quot;empty-l&quot; assert left index of 0 in empty-l is 0;<br> for &quot;ref&quot; assert left index of 1 in ref is 2;<br> for &quot;teens&quot; assert left index of 15 in teens is 3;<br> let l1 be the sum of ref and list9;<br> for &quot;sum of ref and list9&quot; assert left index of 1 in l1 is 2;</font></blockquote>
<p>
<blockquote><font color="#000080"> Rindex is a unit test. &quot;Scooby-doo saying 'windex'&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing rindex:<br> for &quot;empty-l&quot; assert right index of 5 in empty-l is 0;<br> for &quot;empty-l&quot; assert right index of 0 in empty-l is 0;<br> for &quot;rindex 1 in ref&quot; assert right index of 1 in ref is 2;<br> for &quot;rindex 15 in teens&quot; assert right index of 15 in teens is 3;<br> let l1 be the sum of ref and list9;<br> for &quot;rindex 8 in sum of ref and list9&quot; assert right index of 8 in l1 is 11;<br> for &quot;rindex 1 in sum of ref and list9&quot; assert right index of 1 in l1 is 4;</font></blockquote>
<p>
<blockquote><font color="#000080"> Zentry is a unit test. &quot;Zentry&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing zentry:<br> for &quot;empty-l&quot; assert zentry 0 in empty-l is 0;<br> for &quot;ref 0&quot; assert zentry 0 in ref is 0;<br> for &quot;rev-ref -1&quot; assert zentry -1 in rev-ref is 0;<br> for &quot;rev-ref 0th&quot; assert zentry 0 in rev-ref is 2;<br> for &quot;teens 2&quot; assert zentry 2 in teens is 15;<br> for &quot;teens -2&quot; assert zentry -2 in teens is 18;</font></blockquote>
<p>
<blockquote><font color="#000080"> Minmax is a unit test. &quot;Min/max&quot;.</font></blockquote>
<p>
<blockquote><font color="#000080"> For testing minmax:<br> for &quot;min ref&quot; assert min of ref is 0;<br> for &quot;max ref&quot; assert max of ref is 2;<br> for &quot;min teens&quot; assert min of teens is 13;<br> for &quot;max teens&quot; assert max of teens is 19;<br> let L be the shuffled sum of ref and teens;<br> for &quot;min L&quot; assert min of ref is 0;<br> for &quot;max L&quot; assert max of teens is 19;</font></blockquote>
<p>

<p>
<p></body></html>